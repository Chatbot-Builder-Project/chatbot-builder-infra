name: Deploy Manifests

on:
  repository_dispatch:
    types:
      - deploy_chatbot_staging
      - deploy_chatbot_production

permissions:
  contents: read

env:
  TFC_TOKEN: ${{ secrets.TFC_TOKEN }}

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v2

      - name: Configure Terraform Cloud Credentials
        run: |
          mkdir -p $HOME/.terraform.d
          cat <<EOF > $HOME/.terraform.d/credentials.tfrc.json
          {
            "credentials": {
              "app.terraform.io": {
                "token": "${TFC_TOKEN}"
              }
            }
          }
          EOF

      - name: Initialize Terraform and Retrieve Outputs
        run: |
          terraform -chdir=infra init
          terraform -chdir=infra output -json > terraform-outputs.json

      - name: Parse Terraform Outputs
        id: parse_outputs
        run: |
          PRODUCTION_IP=$(jq -r '.production_public_ip.value' terraform-outputs.json)
          STAGING_IP=$(jq -r '.staging_public_ip.value' terraform-outputs.json)
          
          # Parse kube_config object
          KUBE_HOST=$(jq -r '.kube_config.value.host' terraform-outputs.json)
          CLIENT_CERT=$(jq -r '.kube_config.value.client_certificate' terraform-outputs.json)
          CLIENT_KEY=$(jq -r '.kube_config.value.client_key' terraform-outputs.json)
          CA_CERT=$(jq -r '.kube_config.value.cluster_ca_certificate' terraform-outputs.json)

          # Write kubeconfig file
          cat <<EOF > kubeconfig
          apiVersion: v1
          clusters:
          - cluster:
              certificate-authority-data: $CA_CERT
              server: $KUBE_HOST
            name: aks-cluster
          contexts:
          - context:
              cluster: aks-cluster
              user: aks-user
            name: aks-context
          current-context: aks-context
          kind: Config
          preferences: {}
          users:
          - name: aks-user
            user:
              client-certificate-data: $CLIENT_CERT
              client-key-data: $CLIENT_KEY
          EOF

          echo "KUBECONFIG=$(pwd)/kubeconfig" >> $GITHUB_ENV
          echo "PRODUCTION_IP=$PRODUCTION_IP" >> $GITHUB_ENV
          echo "STAGING_IP=$STAGING_IP" >> $GITHUB_ENV

      - name: Set Up Kubectl
        run: |
          export KUBECONFIG=$(pwd)/kubeconfig
          kubectl version --client
          kubectl cluster-info

      - name: Set Load Balancer IPs in Manifests
        run: |
          if [[ "${{ github.event.action }}" == "deploy_chatbot_staging" ]]; then
            LOAD_BALANCER_IP=$STAGING_IP
            NAMESPACE="staging"
          elif [[ "${{ github.event.action }}" == "deploy_chatbot_production" ]]; then
            LOAD_BALANCER_IP=$PRODUCTION_IP
            NAMESPACE="production"
          else
            echo "Unknown event type. Exiting..."
            exit 1
          fi

          echo "Using Load Balancer IP: $LOAD_BALANCER_IP for namespace: $NAMESPACE"

          # Update manifests with the Load Balancer IP
          sed -i "s|\${LOAD_BALANCER_IP}|$LOAD_BALANCER_IP|g" manifests/post-deployment/api-service.yaml

      - name: Update Deployment Manifests with New Image
        run: |
          IMAGE_FULL_NAME="${{ github.event.client_payload.image_full_name }}"
          IMAGE_MANIFEST_NAME="${{ github.event.client_payload.image_manifest_name }}"

          echo "Updating deployments for image: $IMAGE_FULL_NAME"

          # Find and replace occurrences of the image name in deployment manifests
          find manifests/deployment -type f \( -name "*.yaml" -o -name "*.yml" \) -exec \
          sed -i 's|image: '"$IMAGE_MANIFEST_NAME"'|image: '"$IMAGE_FULL_NAME"'|' {} \;

      - name: Inject Namespace into Manifests
        run: |
          echo "Injecting namespace into manifests where missing..."

          # Define the directories to process
          DIRECTORIES=(
            "manifests/pre-deployment"
            "manifests/deployment"
            "manifests/post-deployment"
          )

          for dir in "${DIRECTORIES[@]}"; do
            echo "Processing directory: $dir"
            find "$dir" -type f \( -name "*.yaml" -o -name "*.yml" \) | while read -r file; do
              echo "Checking $file for namespace field..."

              if ! grep -q "namespace:" "$file"; then
                echo "Namespace not found in $file. Adding namespace: $NAMESPACE"
                # Insert `namespace` with proper indentation after `metadata:`
                sed -i '/metadata:/a\  namespace: '"$NAMESPACE" "$file"
              else
                echo "Namespace already defined in $file. Skipping."
              fi
            done
          done

      - name: Apply Namespaces
        run: |
          echo "Applying namespaces..."
          kubectl apply -f manifests/namespaces.yaml

      - name: Apply pre-deployment resources (PVCs, ConfigMaps, Secrets)
        run: |
          echo "Applying all pre-deployment resources recursively."
          find manifests/pre-deployment -type f \( -name "*.yaml" -o -name "*.yml" \) | while read -r file; do
            echo "Applying $file"
            kubectl apply -n "$NAMESPACE" -f "$file"
          done

      - name: Deploy core resources (Deployment, StatefulSet)
        run: |
          echo "Applying all deployment resources recursively."
          find manifests/deployment -type f \( -name "*.yaml" -o -name "*.yml" \) | while read -r file; do
            echo "Applying $file"
            kubectl apply -n "$NAMESPACE" -f "$file"
          done

      - name: Apply post-deployment resources (Services, Ingress, HPA)
        run: |
          echo "Applying all post-deployment resources recursively."
          find manifests/post-deployment -type f \( -name "*.yaml" -o -name "*.yml" \) | while read -r file; do
            echo "Applying $file"
            kubectl apply -n "$NAMESPACE" -f "$file"
          done